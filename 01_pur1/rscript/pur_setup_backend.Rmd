---
title: "pur_setup_backend"
author: "Faza"
date: "2024-08-22"
format: html
editor: source
---

## 1. Input Parameters and Load Library
```{r}
library(foreign)
library(raster)
library(terra)
library(dplyr)
library(sp)

time_start <- Sys.time()
```

```{r}
# Input parameters
ref_data <- "data/pur_test/RTRW_V2Fcr_Raster.tif"
lut_ref <- "data/pur_test/RTRW_F.csv"
ref_class <- "data/pur_test/ref_class.csv"
ref_mapping <- "data/pur_test/ref_mapping.csv"
pu_units <- "data/pur_test/pu_units.csv"
output_dir <- "01_pur1/output/"
```

## 2. Prepare Reference Data

```{r}
# Load and prepare reference data
ref <- raster(ref_data)
ref <- reclassify(ref, cbind(255, 0))

lookup_ref <- read.csv(lut_ref)
colnames(lookup_ref)[ncol(lookup_ref)] <- "REFERENCE"
ref.name <- names(ref)
```

## 3. Projection Handling

```{r}
# Check and handle the projection of the reference data
if (grepl("+units=m", as.character(crs(ref)@projargs))){
  print("Raster maps have projection in meter unit")
  Spat_res<-res(ref)[1]*res(ref)[2]/10000
  paste("Raster maps have ", Spat_res, " Ha spatial resolution, QuES-C will automatically generate data in Ha unit")
} else if (grepl("+proj=longlat", as.character(crs(ref)@projargs))){
  print("Raster maps have projection in degree unit")
  Spat_res<-res(ref)[1]*res(ref)[2]*(111319.9^2)/10000
  paste("Raster maps have ", Spat_res, " Ha spatial resolution, QuES-C will automatically generate data in Ha unit")
} else{
  statuscode<-0
  statusmessage<-"Raster map projection is unknown"
  statusoutput<-data.frame(statuscode=statuscode, statusmessage=statusmessage)
  quit()
}
```

## 4. Merge Reference Data with Reference Class

```{r}
# Load and merge reference class and mapping data
tabel_acuan <- read.table(ref_class, header = FALSE, sep = ",") %>%
  setNames(c("acuan_kelas", "acuan_kode"))

tabel_mapping <- read.table(ref_mapping, header = FALSE, sep = ",") %>%
  setNames(c("REFERENCE", "IDS")) %>%
  left_join(lookup_ref, by = "REFERENCE")

if("COUNT" %in% colnames(tabel_mapping)){
  tabel_mapping <- tabel_mapping %>%
    select(-COUNT) 
}

tabel_mapping <- tabel_mapping %>%
  rename(IDO = ID)

# save reference table and map to temporary folder
target_file <- paste(output_dir, "/reference.csv", sep="")
write.table(tabel_mapping, target_file, quote=FALSE, row.names=FALSE, sep=",")
```

## 5. Prepare Planning Units

```{r}
# Load planning unit data
pu_list <- read.table(pu_units, header=FALSE, sep=",")
n_pu_list <- nrow(pu_list)

# create an empty list to store the results
pu_lut_list <- list()
cmd <- paste()
# command1 <- paste()
command1 <- vector("list", n_pu_list)
central_attr<-NULL

# iterate over each planning unit in the list
for (i in 1:n_pu_list) {
  data_name <- as.character(pu_list[i, 1])
  pu_data <- as.character(pu_list[i, 1])
  lut_table <- pu_list[i, 5]
  pu_raster <- raster(file.path(dirname(lut_table), paste0(pu_data, ".tif")))
  print(pu_raster)
  # Append the lookup table data to a list
  pu_lut_list[[i]] <- lut_table

  # Append 'data_name' to the 'central_attr' list
  central_attr <- append(central_attr, data_name)

  # Reclassify NA and 255 values in the raster data
  pu_raster[is.na(pu_raster)] <- 0  # Set NA values to 0
  pu_raster <- reclassify(pu_raster, cbind(255, 0))  # Reclassify 255 values to 0

  # Rename the raster to 'data_name'
  names(pu_raster) <- data_name

  # Perform calculations involving 'pu_raster' and store in 'R' variables
  j <- n_pu_list + 1 - i
  assign(paste0("R", i), pu_raster * (100^(j)))

  # Build a command for further calculations
  cmd <- paste0(cmd, "R", i, "+")

  command1[[i]] <- pu_raster
}

# Calculate a reference value and store in an 'R' variable
ref.number <- n_pu_list + 1
R_ref <- ref * 1  # Assuming 'ref' is already defined
assign(paste0("R", ref.number), R_ref)

# Update the 'cmd' string with the reference value
cmd <- paste0(cmd, "R", ref.number)

# Combine reference and planning units
# Add the reference raster to the command1 list
command1[[ref.number]] <- R_ref

# Create the PUR_stack
PUR_stack <- stack(command1)
plot(PUR_stack)
```

## 6. Create Raster Attribute Table

```{r}
# Create and process the raster attribute table
eval(parse(text=(paste("PUR<-", cmd, sep=""))))
PUR <- ratify(PUR, count=TRUE)
PUR_db<-levels(PUR)[[1]]

# reclassify attribute ID
ORI_ID<-PUR_db$ID
NEW_ID<-seq(nrow(PUR_db)) 
rclmat<-cbind(as.matrix(ORI_ID), as.matrix(NEW_ID)) 
PUR<-reclassify(PUR, rclmat) 
PUR<-ratify(PUR, count=TRUE)

# extract all ids
PUR_db$NEW_ID<-NEW_ID
PUR_db$TEMP_ID<-PUR_db[,1]
k<-0

# Loop to extract variables from the TEMP_ID using modular arithmetic
while (k < ref.number) {
  eval(parse(text=(paste("PUR_db$Var", n_pu_list - k, "<-PUR_db$TEMP_ID %% 100", sep=""))))
  # Extract the last two digits of TEMP_ID and store in the respective column
  PUR_db$TEMP_ID <- floor(PUR_db$TEMP_ID / 100)  # Divide TEMP_ID by 100 and discard the remainder
  k = k + 1
}

PUR_db$TEMP_ID<-NULL

# conduct reconciliation --------------------------------------------------

colnames(PUR_db)[1] <- "unique_id"
colnames(PUR_db)[2] <- "Freq"
colnames(PUR_db)[4] <- ref.name

m <- 0
for(l in 1:n_pu_list) {
  pu_data <- as.character(pu_list[l, 2])
  var_num <- n_pu_list + 4 - m
  
  # Check if the column exists in PUR_db
  if(var_num <= ncol(PUR_db)) {
    # Use the actual raster object stored in command1 to get the name
    colnames(PUR_db)[var_num] <- names(command1[[l]])
  } else {
    warning(paste("Column", var_num, "does not exist in PUR_db"))
  }
  
  m <- m + 1
}

# combining tabel mapping and pur attribute table
colnames(tabel_mapping)[3]<-ref.name
```

## 7. Conduct Reconciliation

```{r}
# Prepare data for reconciliation
PUR_dbmod<-merge(PUR_db, tabel_mapping, by=ref.name)

for (j in 1:(n_pu_list)) {
  data_name <- as.character(pu_list[j, 1])
  data_value <- pu_list[j, 3]
  Type<-as.character(pu_list[j,4])
  
  # Update the column
  idx_non_zero <- PUR_dbmod[[data_name]] != 0
  PUR_dbmod[idx_non_zero, data_name] <- data_value
  
  # Create new column
  new_col_name <- paste("cek", j, sep = "")
  
  # Reconciliation scenario:
  if(1 == Type){
    # Additional Scenario
    PUR_dbmod[[new_col_name]] <- as.numeric(PUR_dbmod[[data_name]] != 0)
  } else {
    # Reconcile scenario
    PUR_dbmod[[new_col_name]] <- as.numeric(PUR_dbmod[[data_name]] == PUR_dbmod$IDS)
  }
  
}

# check planning unit which is overlapped refer to reference data 
#   if there is no overlapping data then attribute equals to reference,
#   else attribute would become unresolved

command4 <- paste()  # Initialize the command4 variable as an empty character string

# Iterate over each planning unit in the list
for (p in 1:n_pu_list) {
  if (p != n_pu_list) {  # If not the last planning unit
    eval(parse(text=(paste("command4 <- paste(command4, ", '"cek', p, '+', '")', sep=""))))
    # Append "cekX+" to the command4 string, where X is the planning unit index
  } else {  # If the last planning unit
    eval(parse(text=(paste("command4 <- paste(command4, ", '"cek', p, '")', sep=""))))
    # Append "cekX" to the command4 string for the last planning unit
  }
}

# Calculate the value of 'reconcile1' column based on 'command4' string
PUR_dbmod <- within(PUR_dbmod, { reconcile1 <- eval(parse(text=(command4))) })
# This evaluates the concatenated command4 string as R code and assigns the result to the 'reconcile1' column

# Calculate the 'reconcile_attr' column based on 'reconcile1' values
PUR_dbmod <- within(PUR_dbmod, {
  reconcile_attr <- ifelse(reconcile1 == 0, as.character(REFERENCE), "unresolved")
})
# If 'reconcile1' is 0, set 'reconcile_attr' to the value of 'REFERENCE', otherwise set it to "unresolved"

# put an ID in overlapped/reconcile attribute 

command5 <- paste()  # Initialize the command5 variable as an empty character string

# Iterate over each planning unit in the list
for (r in 1:n_pu_list) {
  if (r != n_pu_list) {  # If not the last planning unit
    eval(parse(text=(paste("command5 <- paste(command5, ", '"(cek",', r,',"*",', r, ', ")+", sep="")', sep=""))))
    # Append "(cekX*X)+" to the command5 string, where X is the planning unit index
  } else {  # If the last planning unit
    eval(parse(text=(paste("command5 <- paste(command5, ", '"(cek",', r,',"*",', r, ', ")", sep="")', sep=""))))
    # Append "(cekX*X)" to the command5 string for the last planning unit
  }
}

# Calculate the 'reconcile_attr2' column based on conditions and 'command5' string
PUR_dbmod <- within(PUR_dbmod, {
  reconcile_attr2 <- ifelse(reconcile1 == 1, eval(parse(text=(command5))), 100)
})
# If 'reconcile1' is 1, calculate 'reconcile_attr2' using the concatenated command5 string,
# otherwise set 'reconcile_attr2' to 100
```

## 8. Create Central Attribute of Planning Units

```{r}
# Create and process central attributes
central_attr <- central_attr %>%
  as_tibble() %>%
  mutate(numb_ca = row_number()) %>%
  dplyr::select(numb_ca, everything())

central_attrmod <- central_attr %>%
  rename(Rec_phase1 = 2, reconcile_attr2 = 1)

add_22 <- tibble(Rec_phase1 = "none", reconcile_attr2 = 100)

# Convert Rec_phase1 column to character in central_attrmod
central_attrmod <- central_attrmod %>%
  mutate(Rec_phase1 = as.character(Rec_phase1))

# Combine the data frames and convert reconcile_attr2 column to numeric
central_attrmod <- bind_rows(central_attrmod, add_22) %>%
  mutate(reconcile_attr2 = as.numeric(reconcile_attr2))
```

## 9. Finalize and Save Results

```{r}
# Finalize reconciliation results
PUR_dbfinal <- PUR_dbmod %>% 
  inner_join(central_attrmod, by = "reconcile_attr2") %>%
  mutate(Rec_phase1 = ifelse(Rec_phase1 == "none", as.character(reconcile_attr), as.character(Rec_phase1))) %>%
  mutate(Rec_phase1b = ifelse(reconcile_attr == "unresolved", "unresolved_case", as.character(Rec_phase1)))

PUR_dbfinal2 <- PUR_dbfinal %>% 
  dplyr::select(NEW_ID, Rec_phase1b) %>%
  setNames(c("ID", "Rec_phase1b"))

levels(PUR) <- merge(levels(PUR), PUR_dbfinal2 %>% 
                       distinct(ID, Rec_phase1b), by = "ID")
# Merge classes based on Rec_phase 1b column ------------------------------
# 1. Extract levels of the raster into a data frame
df_levels <- as.data.frame(levels(PUR)[[1]])
# 2. Assign new unique IDs for each category in Rec_phase1b
# We exclude 'unresolved_case' here as mentioned
unique_categories <- unique(df_levels$Rec_phase1b[df_levels$Rec_phase1b != "unresolved_case"])
category_mapping <- setNames(1:length(unique_categories), unique_categories)

df_levels$ID_rec <- ifelse(df_levels$Rec_phase1b == "unresolved_case", 
                           df_levels$ID, 
                           category_mapping[df_levels$Rec_phase1b])

PUR_dbfinal<- bind_cols(PUR_dbfinal, df_levels["ID_rec"])

# Filter out 'unresolved_case'
filtered_df <- df_levels |>
  subset(Rec_phase1b != "unresolved_case")

# Group by 'Rec_phase1b' and summarise
merged_df <- filtered_df |> 
  group_by(ID_rec, Rec_phase1b) |> 
  summarise(Total_COUNT = sum(COUNT)) |> 
  ungroup() |> 
  mutate(Rec_phase1b = as.character(Rec_phase1b))
# Add back 'unresolved_case' with its COUNT
unresolved_cases <- df_levels |> 
  filter(Rec_phase1b == "unresolved_case") |> 
  group_by(ID_rec) |> 
  summarise(Rec_phase1b = "unresolved_case", Total_COUNT = sum(COUNT)) |> 
  ungroup() |> 
  mutate(Rec_phase1b = as.character(Rec_phase1b))

db_final2 <- rbind(merged_df, unresolved_cases)
colnames(db_final2) <- c("ID","Rec_phase1b" , "COUNT")

# Build the reclassification matrix
reclass_matrix <- as.matrix(df_levels[, c('ID', 'ID_rec')])

# reclassify the PUR raster
PUR_reclassified <- reclassify(PUR, reclass_matrix) |> ratify()
levels(PUR_reclassified) <- merge(levels(PUR_reclassified), db_final2, by = "ID")

# write PUR reconciliation phase 1 raster
write.dbf(PUR_dbfinal, paste0(output_dir, "PUR-build_database.dbf"))
writeRaster(PUR, filename=paste0(output_dir, "PUR_reconciliation_result"), format="GTiff", overwrite=TRUE)
# writeRaster(PUR_reclassified, filename="PUR_reconciliation_result_dissolved", format="GTiff", overwrite=TRUE)

PUR_rec1_shp  <- as.polygons(rast(PUR_reclassified))
writeVector(PUR_rec1_shp, filename = paste(output_dir, "/PUR_reconciliation_result.shp", sep=""), overwrite=TRUE)

#=Save PUR final database and unresolved case(s) 
database_unresolved<-subset(PUR_dbfinal, Rec_phase1b == "unresolved_case") |> dplyr::select(-ID_rec)

# save final database for viz
#database_final <- as.data.frame(levels(PUR))
#database_final$COUNT_ha <- database_final$COUNT * Spat_res

data_attribute <- db_final2 %>%
  dplyr::select(-COUNT) 

# Identify missing strings
missing_strings <- setdiff(unique(PUR_dbfinal[["Rec_phase1"]]), data_attribute$Rec_phase1b)

# Append missing strings to the data_attribute tibble
if (length(missing_strings) > 0) {
  new_IDs <- max(data_attribute$ID) + seq_along(missing_strings)
  new_rows <- tibble(ID = new_IDs, Rec_phase1b = missing_strings)
  data_attribute <- bind_rows(data_attribute, new_rows)
}

write.table(data_attribute, paste0(output_dir, "/PUR_attribute.csv"), quote=FALSE, row.names=FALSE, sep=",")
#PUR_dbfinal <- PUR_dbfinal |> select(-ID_rec)
write.table(PUR_dbfinal, paste0(output_dir, "/PUR_dbfinal.csv"), quote=FALSE, row.names=FALSE, sep=",")
# write.dbf(data_attribute, "PUR_attribute.dbf")

plot(PUR_rec1_shp)
```

## 10. Handle Unresolved Cases

```{r}
# Process and save unresolved cases if any
if (nrow(unresolved_cases) != 0) {
  len <- nrow(database_unresolved)
  for(r in 1:n_pu_list){
    pu_data <- as.character(pu_list[r,2])
    word1 <- paste0("cek", r)
    word2 <- paste0("PU_", r)
    
    # Initialize the new column with "NULL"
    database_unresolved[[word2]] <- "NULL"
    
    # Use vectorized operations instead of loop
    database_unresolved[[word2]] <- ifelse(database_unresolved[[word1]] > 0, 
                                           names(command1[[r]]), 
                                           "-")
  }
  
  numberx <- ncol(database_unresolved)
  numbery <- numberx - n_pu_list
  database_unresolved_out <- database_unresolved[, c(numbery:numberx)]
  dat1 <- data.frame(ID = database_unresolved$NEW_ID)
  dat2 <- data.frame(COUNT = database_unresolved$Freq)
  dat3 <- data.frame(REFERENCE = database_unresolved$REFERENCE)
  database_unresolved_out <- cbind(dat1, database_unresolved_out, dat3, dat2)
  
  write.table(database_unresolved_out, paste0(output_dir, "/PUR_unresolved_case.csv"), quote=FALSE, row.names=FALSE, sep=",")
} else {
  database_unresolved_out <- tibble("Reconciliation result" = "There are no unresolved areas in this analysis session")
}
```

## 11. Final Output Processing

```{r}
# Prepare final output for GIS
PUR_rec1 <- PUR
attr_df <- as.data.frame(levels(PUR)[[1]])
levels(PUR_rec1)[[1]] <- attr_df |> select(-COUNT)

PUR_rec1_shp  <- as.polygons(rast(PUR_rec1), values=TRUE)
# Merge the attributes to the polygons based on the ID
PUR_rec1_shp$ID <- attr_df$ID

PUR_rec1_shp <- PUR_rec1_shp |> sf::st_as_sf() |> sf::as_Spatial()
PUR_rec1_shp <- PUR_rec1_shp[, c("ID", "layer")]
names(PUR_rec1_shp)[names(PUR_rec1_shp) == "layer"] <- "Rec_phase1b"
```

## 12. Finalization

```{r}
time_end <- Sys.time ()
run_time <- time_end - time_start
```
